`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 04/07/2022 09:45:03 AM
// Design Name: 
// Module Name: MotorControl
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module MotorControl(

        output [7:0] led,
        input  sys_clkn,
        input  sys_clkp,
        /*
        output ADT7420_A0,
        output ADT7420_A1,
        output I2C_SCL_0,
        inout  I2C_SDA_0,        
        output reg FSM_Clk_reg,    
        output reg ILA_Clk_reg,
        output reg ACK_bit,
        output reg SCL,
        output reg SDA,
        */
        output EN,
        output DIR,
        output reg [7:0] State,
        output wire [31:0] PC_control, //start to trigger FSM
        output wire [31:0] Pulses, //number of pulses motor should go on for
        output wire [31:0] Dir, //direction of motor: 0 = forward, 1= reverse
        output wire [31:0] DC, //duty cycle
        input  wire    [4:0] okUH,
        output wire    [2:0] okHU,
        inout  wire    [31:0] okUHU,   
        inout wire okAA 

    );
    
    
    reg [23:0] clkdiv;
    reg slow_clk;
    reg [7:0] counter; //counter to count how many pulses have been passed
    reg [3:0] DCcounter; //counter to count how much DC 1's and 0's have been passed
    reg ENr; //regiter to hold enable value
    
    // This section defines the main system clock from two
    //differential clock signals: sys_clkn and sys_clkp
    // Clk is a high speed clock signal running at ~200MHz
    wire clk;
    IBUFGDS osc_clk(
        .O(clk),
        .I(sys_clkp),
        .IB(sys_clkn)
    );
    
    initial begin
        clkdiv = 0;
    end
      
    // This code creates a slow clock from the high speed Clk signal
    // You will use the slow clock to run your finite state machine
    // The slow clock is derived from the fast 20 MHz clock by dividing it 10,000,000 time
    // Hence, the slow clock will run at 200 Hz
    always @(posedge clk) begin
        clkdiv <= clkdiv + 1'b1;
        if (clkdiv == 100000) begin //want clock used in FSM to be 10x's faster so that full period will be 1/200Hz 
            slow_clk <= ~slow_clk;
            clkdiv <= 0;
        end
    end

    localparam STATE_INIT       = 8'd0;  
    assign EN = ENr; //assign enable register to enable output wire signal

    always @(posedge slow_clk) begin                       
        case (State)
            // Press signal from PC is sent in, start the state machine. Otherwise, stay in the STATE_INIT state        
            STATE_INIT : begin
                 if (PC_control[0] == 1'b1) begin
                    if (DC==0)
                        State <= 8'd11;
                    else 
                        State <= 8'd1; 
                    counter <= 8'd0; //how many pulses we've finished
                    DCcounter <= 4'd1;
                 end                 
                 else begin                 
                      State <= 8'd0;
                  end
            end            
            
            // Start creating PWM- loading 1's into enable          
            8'd1 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                                                
            end   
            
            8'd2 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                     
            end  
            
            8'd3 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                                    
            end   
            
            8'd4 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                   
            end 
            
            8'd5 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                      
            end  
            
            8'd6 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                     
            end  
            
            8'd7 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                   
            end  
            
            8'd8 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                      
            end  
            
            8'd9 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                      
            end 
            
            8'd10 : begin
                  ENr <= 1;
                  if (DCcounter == DC) begin
                    State <= 8'd11;
                    DCcounter <= 0;
                  end
                  else begin
                    State <= State + 1'b1;  
                    DCcounter <= DCcounter + 1'b1;  
                  end                      
            end   
            
            //loading 0's into enable
            8'd11 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd12 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd13 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd14 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd15 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd16 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd17 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd18 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end  
            
            8'd19 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end 
            
            8'd20 : begin
                  ENr <= 0;
                  State <= State + 1'b1;                 
            end   
            
            8'd21 : begin //cycling state control
            
            
            end

        endcase
    end












// OK Interface
    wire [112:0]    okHE;  //These are FrontPanel wires needed to IO communication    
    wire [64:0]     okEH;  //These are FrontPanel wires needed to IO communication 
        //Depending on the number of outgoing endpoints, adjust endPt_count accordingly.
    //In this example, we have 2 output endpoints, hence endPt_count = 2.
    localparam  endPt_count = 0;
    wire [endPt_count*65-1:0] okEHx;  
    okWireOR # (.N(endPt_count)) wireOR (okEH, okEHx);
    wire okClk;
    
    //This is the OK host that allows data to be sent or recived    
    okHost hostIF (
        .okUH(okUH),
        .okHU(okHU),
        .okUHU(okUHU),
        .okClk(okClk),
        .okAA(okAA),
        .okHE(okHE),
        .okEH(okEH)
    );
    
    //  PC_controll is a wire that contains data sent from the PC to FPGA.
    //  The data is communicated via memeory location 0x00
   okWireIn wire10 (   .okHE(okHE), 
                       .ep_addr(8'h00), 
                       .ep_dataout(PC_control)); //signal to tell motor control to start
                       
   okWireIn wire11 (   .okHE(okHE), 
                       .ep_addr(8'h01), 
                       .ep_dataout(Pulses)); //signal to tell motor how many pulses to go for
                       
   okWireIn wire12 (   .okHE(okHE), 
                       .ep_addr(8'h02), 
                       .ep_dataout(Dir)); //signal to tell motor what direction to go in
                   
endmodule










