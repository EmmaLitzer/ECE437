`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 

// Engineer: 
// 
// Create Date: 02/03/2022 10:45:15 AM
// Design Name: 
// Module Name: Exercise 1
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

module Ex2(
        input   wire    [4:0] okUH,
        output  wire    [2:0] okHU,
        inout   wire    [31:0] okUHU,
        inout   wire    okAA,
        input   wire    sys_clkn,
        input   wire    sys_clkp,
        input   wire    reset,
        // Your signals go here
        input [3:0] button,
        output [7:0] led
    );
       
    wire okClk;            //These are FrontPanel wires needed to IO communication    
    wire [112:0]    okHE;  //These are FrontPanel wires needed to IO communication    
    wire [64:0]     okEH;  //These are FrontPanel wires needed to IO communication    
            
    //Declare your registers or wires to send or recieve data
    wire [31:0] variable;      //signals that are outputs from a module must be wires
    wire [31:0] clk_freq;                 //signals that go into modules can be wires or registers
    reg [31:0] result_register;
    reg [7:0] counter;
        
    //This is the OK host that allows data to be sent or recived    
    okHost hostIF (
        .okUH(okUH),
        .okHU(okHU),
        .okUHU(okUHU),
        .okClk(okClk),
        .okAA(okAA),
        .okHE(okHE),
        .okEH(okEH)
    );
        
    //Depending on the number of outgoing endpoints, adjust endPt_count accordingly.
    //In this example, we have 2 output endpoints, hence endPt_count = 2.
    localparam  endPt_count = 2;
    wire [endPt_count*65-1:0] okEHx;  
    okWireOR # (.N(endPt_count)) wireOR (okEH, okEHx);
    
    // Clock
    wire clk;
    reg [31:0] clkdiv;
    reg slow_clk;
    reg [31:0] clkdiv_set;

    
    IBUFGDS osc_clk(
        .O(clk),
        .I(sys_clkp),
        .IB(sys_clkn)
    );
    
    initial begin
        clkdiv = 0;
        slow_clk = 0;
        counter = 8'h00;
    end

    // This code creates a slow clock from the high speed Clk signal
    // You will use the slow clock to run your finite state machine
    // The slow clock is derived from the fast 200 MHz clock by dividing it 10,000,000 time and another 2x to run at 10Hz
    // Divide 200MHz with wanted clock frequency to get divisor of how many times the real clock has to count up to generate the slow clock

    always @(posedge clk) begin
        clkdiv_set <= (200_000_000/clk_freq); //unsure if this division operator works
        clkdiv <= clkdiv + 1'b1;
        if (clkdiv == clkdiv_set) begin
            slow_clk <= ~slow_clk;
            clkdiv <= 0;
        end
    end
    
    assign led = ~counter;
     
    
    //beginning of exercise code
    
    //  variable is a wire that contains data of the LED condition sent from the PC to FPGA.
    //  The data is communicated via memeory location 0x00
    okWireIn wire10 (   .okHE(okHE), 
                        .ep_addr(8'h00), 
                        .ep_dataout(variable));
                        
    //  clk_freq is a wire that contains data of what clock frequency is wanted sent from the PC to FPGA.
    //  The data is communicated via memeory location 0x01               
    okWireIn wire11 (   .okHE(okHE), 
                        .ep_addr(8'h01), 
                        .ep_dataout(clk_freq));
    
    //Depending on the variable value, LED pattern changes
   always @(posedge slow_clk) begin
   
        if (reset == 1)
            counter <= 8'h00; 
        else if (variable == 0)
            counter <= 8'b11111111;
        else if (variable == 1)
            counter <= 8'd0;
        else if (variable == 2)
            counter <= counter + 8'd2;
        else if (variable == 3)
            counter <= counter - 8'd2;
    end 

    // result_wire is transmited to the PC via address 0x20
    /*   
    okWireOut wire20 (  .okHE(okHE), 
                        .okEH(okEHx[ 0*65 +: 65 ]),
                        .ep_addr(8'h20), 
                        .ep_datain(result_wire));
     */                   
                        
    // Variable 1 and 2 are subtracted and the result is stored in a register named: result_register
    // Since we are using a register to store the result, we not need a clock signal and 
    // we will use an always statement examening the clock state   
    always @ (posedge(slow_clk)) begin
        result_register = counter;
    end
    
    // result_wire is transmited to the PC via address 0x21                         
    okWireOut wire21 (  .okHE(okHE), 
                        .okEH(okEHx[ 1*65 +: 65 ]),
                        .ep_addr(8'h21), 
                        .ep_datain(result_register));          
endmodule
